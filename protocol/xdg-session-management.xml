<?xml version="1.0" encoding="UTF-8"?>
<protocol name="xdg_session_management_v1">
  <copyright>
    Copyright 2018 Mike Blumenkrantz
    Copyright 2018 Samsung Electronics Co., Ltd
    Copyright 2018 Red Hat Inc.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice (including the next
    paragraph) shall be included in all copies or substantial portions of the
    Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
  </copyright>

  <description summary="Protocol for managing application sessions">
    Warning! The protocol described in this file is currently in the testing
    phase. Backward compatible changes may be added together with the
    corresponding interface version bump. Backward incompatible changes can
    only be done by creating a new major version of the extension.
  </description>

  <interface name="xdg_session_manager_v1" version="1">
    <description summary="manage sessions for applications">
      The xdg_session_manager interface defines base requests for creating and
      managing a session for an application. Sessions persist across application
      and compositor restarts unless explicitly destroyed. A session is created
      for the purpose of maintaining an application's xdg_toplevel surfaces
      across compositor or application restarts. The compositor should remember
      as many states as possible for surfaces in a given session, but there is
      no requirement for which states must be remembered.
    </description>

    <enum name="error">
      <entry name="in_use" summary="a requested session is already in use"
	     value="1"/>
    </enum>

    <request name="destroy" type="destructor">
      <description summary="Destroy this object">
       This has no effect other than to destroy the xdg_session_manager object.
      </description>
    </request>

    <request name="get_session">
      <description summary="create or restore a session">
	Create a session object corresponding to the given session
	identifier string. While the session object exists, the session is
	considered to be "in use".

	If a identifier string represents a session that is currently actively
	in use by the client, an 'in_use' error is raised.

	NULL is passed to initiate a new session. If an id is passed which does
	not represent a valid session, the compositor treats it as if NULL had
	been passed.

	A client is allowed to have any number of in use sessions at the same
	time.
      </description>
      <arg name="id" type="new_id" interface="xdg_session_v1"/>
      <arg name="session" type="string" summary="the session identifier string"
	   allow-null="true"/>
    </request>
  </interface>

  <interface name="xdg_session_v1" version="1">
    <description summary="A session for an application">
      A xdg_session_v1 object represents a session for an application. While the
      object exists, all surfaces which have been added to the session will
      have states stored by the compositor which can be reapplied at a later
      time. Two sessions cannot exist for the same identifier string.

      States for surfaces added to a session are automatically updated by the
      compositor when they are changed.

      Surfaces which have been added to a session are automatically removed from
      the session if xdg_toplevel.destroy is called for the surface.
    </description>

    <enum name="error">
      <entry name="invalid_restore"
	     summary="restore cannot be performed after initial toplevel commit"
	     value="1"/>
    </enum>

    <request name="destroy" type="destructor">
      <description summary="Destroy the session">
	Destroy a session object, preserving the current state but not continuing
	to make further updates if state changes occur. This makes the associated
	toplevel session objects inert.
      </description>
    </request>

    <request name="remove" type="destructor">
      <description summary="Remove the session">
	Remove the session, making it no longer available for restoration. A
	compositor should in response to this request remove the data related to
	this session from its storage.
      </description>
    </request>

    <request name="add_toplevel">
      <description summary="add a new surface to the session">
	Attempt to add a given surface to the session. If successful,
	a xdg_toplevel_session_v1.toplevel_id event is emitted with a
	session-unique identifier which can be used to restore states of the
	toplevel surface.

	Multiple requests for the same surface will always return the same
	string identifier.

	The surface will be added to the session at the next wl_surface.commit.
      </description>
      <arg name="id" type="new_id" interface="xdg_toplevel_session_v1"/>
      <arg name="surface" type="object" interface="xdg_toplevel"/>
    </request>

    <request name="restore_toplevel">
      <description summary="restore a surface state">
	Inform the compositor that the next configured state should
	be the same as the state which was stored by the compositor during the
	given surface's previous session.

	This request must be called prior to the first commit for an
	xdg_toplevel surface.

	See the xdg_toplevel_session_v1.surface_restored event for further
	details.

	If a client attempts to restore a toplevel multiple times for the same
	session, an 'invalid_restore' error is raised.
      </description>
      <arg name="id" type="new_id" interface="xdg_toplevel_session_v1"/>
      <arg name="toplevel" type="object" interface="xdg_toplevel"/>
      <arg name="toplevel_id" type="string"
	   summary="the identifier for the toplevel"/>
    </request>

    <request name="remove_toplevel">
      <description summary="remove a surface from the session">
	Remove a specified surface from the session and render any corresponding
	xdg_toplevel_session_v1 object inert. The compositor should remove any
	data related to the toplevel in the corresponding session from its internal
	storage.

	Passing an unknown surface identifier has no effect.
      </description>
      <arg name="toplevel_id" type="string"/>
    </request>

    <event name="created">
      <description summary="newly-created session id">
	Emitted immediately after creating a new session object. This id can be
	used to restore previous sessions.
      </description>
      <arg name="id" type="string"/>
    </event>

    <event name="restored">
      <description summary="the session has been restored">
	The session has been restored from a previous state.
      </description>
    </event>
  </interface>

  <interface name="xdg_toplevel_session_v1" version="1">
    <request name="destroy" type="destructor">
      <description summary="Destroy the object">
	Destroy the object.
      </description>
    </request>

    <event name="restored">
      <description summary="a toplevel's session has been restored">
	The "restored" event is emitted prior to the first
	xdg_toplevel.configure for the toplevel. It will only be emitted after
	xdg_session_v1.restore_toplevel and wl_surface.commit have been called
	for that surface, and it indicates that the surface's session is being
	restored with this configure event.
      </description>
      <arg name="surface" type="object" interface="xdg_toplevel"/>
    </event>

    <event name="toplevel_id">
      <description summary="a surface has been added to the session">
	The toplevel_id event is emitted after the wl_surface.commit of a
	surface which has been passed to add_toplevel. The id is an identifier
	which can be passed to xdg_session_v1.restore_toplevel to restore the
	state of that surface.
      </description>
      <arg name="surface" type="object" interface="xdg_toplevel"/>
      <arg name="id" type="string"/>
    </event>
  </interface>
</protocol>
